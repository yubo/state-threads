BUILDING

To build the library by hand, use the GNU make utility.  Run the make
command (e.g., `gmake') with no arguments to display all supported
targets.

To build more or less automatically, first set the CONFIG_GUESS_PATH
variable in either osguess.sh or your environment then run "make
default" which guesses your OS and builds.  Requires the "config.guess"
utility from GNU autoconf (not included with ST).  You can use one from
a larger "main" software project or just use any config.guess available
on your system.  You can also get it directly from GNU:
ftp://ftp.gnu.org/gnu/autoconf/

To build rpms (RedHat Linux 6.2 or later, Linux/Mandrake, Solaris with
gnome, etc.):
    download the latest st-x.y.tar.gz
    # rpm -ta st-x.y.tar.gz
The .rpms will land in /usr/src/RPMS/<arch>.  Install them with:
    # rpm -i libst*.rpm
Requires GNU automake and rpm 3.0.3 or later.

To build debs (Debian potato or later on Linux):
    download the latest st-x.y.tar.gz
    $ tar xvzf st-x.y.tar.gz
    $ cd st-x.y
    $ debuild
The .debs will land in the parent directory.  Install them with:
    # dpkg -i libst*.deb
Requires GNU automake, debhelper 2.0.86 or later, devscripts, and fakeroot.

If your application uses autoconf to search for dependencies and you
want to search for a given version of libst, you can simply add
        PKG_CHECK_MODULES(MYAPP, st >= 1.3 mumble >= 0.2.23)
to your configure.ac/in.  This will define @MYAPP_LIBS@ and
@MYAPP_CFLAGS@ which you may then use in your Makefile.am/in files to
link against mumble and st.


LICENSE

The State Threads library is a derivative of the Netscape Portable
Runtime library (NSPR).  All source code in this directory is
distributed under the terms of the Mozilla Public License (MPL) version
1.1 or the GNU General Public License (GPL) version 2 or later.  For
more information about these licenses please see
http://www.mozilla.org/MPL/ and http://www.gnu.org/copyleft/.

All source code in the "examples" directory is distributed under the BSD
style license.


DOCUMENTATION

The library documentation can be found in the "docs" directory.
For more information about this project, please see

    http://state-threads.sourceforge.net/


PLATFORMS

Please see the "docs/notes.html" file for the list of currently supported
platforms.


DEBUGGER SUPPORT

It's almost impossible to print SP and PC in a portable way.  The only
way to see thread's stack platform-independently is to actually jump to
the saved context.  That's what the _st_iterate_threads() function does.
Do the following to iterate over all threads:

- set the _st_iterate_threads_flag to 1 in debugger
- set breakpoint at the _st_show_thread_stack() function
  (which does nothing)
- call the _st_iterate_threads() function which jumps to the
  next thread
- at each break you can explore thread's stack
- continue
- when iteration is complete, you return to the original
  point (you can see thread id and a message as arguments of
  the _st_show_thread_stack() function).

You can call _st_iterate_threads() in three ways:

- Insert it into your source code at the point you want to
  go over threads.
- Just run application and this function will be called at
  the first context switch.
- Call it directly from the debugger at any point.

This works with gdb and dbx.

Example using gdb:

(gdb) set _st_iterate_threads_flag = 1
(gdb) b _st_show_thread_stack
...
(gdb) call _st_iterate_threads()
...
(gdb) bt
...
(gdb) c
...
(gdb) bt
...
(gdb) c
...
and so on...

_st_iterate_threads_flag will be set to 0 automatically
after iteration is over or you can set it to 0 at any time
to stop iteration.

Sometimes gdb complains about SIGSEGV when you call a function
directly at gdb command-line.  It can be ignored -- just call the
same function right away again, it works just fine.  For example:

(gdb) set _st_iterate_threads_flag = 1
(gdb) b _st_show_thread_stack
Breakpoint 1 at 0x809bbbb: file sched.c, line 856.
(gdb) call _st_iterate_threads()
Program received signal SIGSEGV, Segmentation fault.
....
(gdb) # just call the function again:
(gdb) call _st_iterate_threads()
Breakpoint 1, _st_show_thread_stack (thread=0x4017aee4, messg=0x80ae7a2
"Iteration started")    at sched.c:856
856     }
....

You can use simple gdb command-line scripting to display
all threads and their stack traces at once:

(gdb) while _st_iterate_threads_flag
 >bt
 >c
 >end
....

Another script to stop at the thread with the specific thread id
(e.g., 0x40252ee4):

(gdb) # set the flag again:
(gdb) set _st_iterate_threads_flag = 1
(gdb) call _st_iterate_threads()
Breakpoint 1, _st_show_thread_stack (thread=0x4017aee4, messg=0x80ae7a2
"Iteration started")    at sched.c:856
856     }
....
(gdb) while thread != 0x40252ee4
 >c
 >end
....
....
Breakpoint 1, _st_show_thread_stack (thread=0x40252ee4, messg=0x0) at
sched.c:856
856     }
(gdb) bt
....
(gdb) # don't want to continue iteration, unset the flag:
(gdb) set _st_iterate_threads_flag = 0
(gdb) c
Continuing.
Breakpoint 1, _st_show_thread_stack (thread=0x0, messg=0x80ae78e "Iteration
completed")
    at sched.c:856
856     }
(gdb) c
Continuing.
(gdb) return
Make selected stack frame return now? (y or n) y
#0  0x4011254e in __select ()
   from /lib/libc.so.6
(gdb) detach


CHANGE LOG

Changes from 1.2 to 1.3.
------------------------
o  Added st_read_resid() and st_write_resid() to allow the caller to know
   how much data was transferred before an error occurred.  Updated
   documentation.

o  Updated project link, copyrights, and documentation regarding
   timeouts.  Added comment to st_connect().

o  Optimized the _st_add_sleep_q() function in sched.c.  Now we walk the
   sleep queue *backward* when inserting a thread into it.  When you
   have lots (hundreds) of threads and several timeout values, it takes
   a while to insert a thread at the appropriate point in the sleep
   queue.  The idea is that often this appropriate point is closer to
   the end of the queue rather than the beginning.  Measurements show
   performance improves with this change.  In any case this change
   should do no harm.

o  Added a hint of when to define USE_POLL and when not to, to the
   Makefile.

o  Added debugging support (files common.h and sched.c).   See above.

o  Decreased the number of reallocations of _ST_POLLFDS in sched.c.
   Inspired by Lev Walkin.

o  Fixed st_usleep(-1) and st_sleep(-1), and added a warning to the
   documentation about too-large timeouts.

o  Linux/*BSD Alpha port.

o  Wesley W. Terpstra modernized the build process:
   - properly build relocatable libraries under bsd and linux
   - use library versioning
   - added rpm spec file
   - added debian/ files
   See above for build instructions.


Changes from 1.1 to 1.2.
------------------------
o  Added st_randomize_stacks().

o  Added a patch contributed by Sascha Schumann.


Changes from 1.0 to 1.1.
------------------------
o  Relicensed under dual MPL-GPL.

o  OpenBSD port.

o  Compile-time option to use poll() instead of select() for
   event polling (see Makefile).
   This is useful if you want to support a large number of open
   file descriptors (larger than FD_SETSIZE) within a single
   process.

o  Linux IA-64 port.
   Two issues make IA-64 different from other platforms:

   - Besides the traditional call stack in memory, IA-64 uses the
     general register stack.  Thus each thread needs a backing store
     for the register stack in addition to the memory stack.

   - Current implementation of setjmp()/longjmp() can not be used
     for thread context-switching since it assumes that only one
     register stack exists.  Using special assembly functions for
     context-switching is unavoidable.
    
o  Thread stack capping on IRIX.
   This allows some profiling tools (such as SpeedShop) to know when
   to stop unwinding the stack.  Without this libexc, used by SpeedShop,
   traces right off the stack and crashes.

o  Miscellaneous documentation additions.


COPYRIGHTS

Portions created by SGI are Copyright (C) 2000 Silicon Graphics, Inc.
All Rights Reserved.
